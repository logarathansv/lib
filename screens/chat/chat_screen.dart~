import 'package:dash_chat_2/dash_chat_2.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:hugeicons/hugeicons.dart';
import '../../models/chat_model/chat_message.dart';
import '../../providers/chat_provider.dart';
import '../../utils/socket/socket_service.dart';

class ChatScreen extends ConsumerStatefulWidget {
  final String currentUserId;
  final String receiverId;
  final String receiverName;

  ChatScreen({
    required this.currentUserId,
    required this.receiverId,
    required this.receiverName,
  });

  @override
  _ChatScreenState createState() => _ChatScreenState();
}

class _ChatScreenState extends ConsumerState<ChatScreen> {
  late SocketService socketService;
  bool isSocketInitialized = false;

  @override
  void initState() {
    super.initState();
    socketService = SocketService();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _initializeSocketListener(); // Initialize socket once
  }

  void _initializeSocketListener() {
    final socket = socketService.socket;

    // Remove existing listener to prevent duplication
    socket.off('receiveMessage');

    socket.on('receiveMessage', (data) {
      final newMessage = Message.fromJson(data);
      if ((newMessage.sender == widget.currentUserId && newMessage.receiver == widget.receiverId) ||
          (newMessage.receiver == widget.currentUserId && newMessage.sender == widget.receiverId)) {
        setState(() {
          messages.insert(
            0,
            ChatMessage(
              text: newMessage.content,
              user: ChatUser(id: newMessage.sender),
              createdAt: newMessage.timestamp,
            ),
          );
        });
      }
    });
  }

  @override
  void dispose() {
    socketService.socket.off('receiveMessage'); // Clean up socket listener
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final senderNameAsync = ref.watch(nameProvider);
    final chatAsync = ref.watch(chatProvider(widget.receiverId));

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          onPressed: () {
            Navigator.pop(context);
            ref.invalidate(chatProvider(widget.receiverId)); // Reset messages when exiting
          },
          icon: HugeIcon(
            icon: HugeIcons.strokeRoundedArrowLeft03,
            color: Colors.black,
          ),
        ),
        title: Text(widget.receiverName),
        backgroundColor: Colors.white,
      ),
      body: senderNameAsync.when(
        data: (senderName) {
          return chatAsync.when(
            data: (messages) {
              return DashChat(
                currentUser: ChatUser(id: widget.currentUserId),
                onSend: (ChatMessage newMessage) {
                  if (senderName.isEmpty) {
                    print("Sender name not loaded yet!");
                    return;
                  }

                  socketService.socket.emit('message', {
                    'senderId': widget.currentUserId,
                    'receiverId': widget.receiverId,
                    "senderName": senderName,
                    "receiverName": widget.receiverName,
                    'content': newMessage.text,
                  });

                  ref.read(chatProviders(widget.receiverId).notifier).addMessage(newMessage);
                },
                messages: messages,
                inputOptions: InputOptions(
                  alwaysShowSend: true,
                ),
              );
            },
            loading: () => Center(child: CircularProgressIndicator()),
            error: (e, st) => Center(child: Text('Error fetching messages: $e')),
          );
        },
        loading: () => Center(child: CircularProgressIndicator()),
        error: (e, st) => Center(child: Text('Error fetching name: $e')),
      ),
    );
  }
}
